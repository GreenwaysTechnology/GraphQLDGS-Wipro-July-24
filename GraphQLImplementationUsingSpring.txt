
			   Graphql Implemenation
....................................................................................
GraphQL Application Dev
.....................................................................................

Graphql application can be developmed using 

1.Monoloithic style-  standalone app
2.Microservice style - Federation



Work Flow
1.SDL must be there and must be very clear.

GraphQL Application can be written in any language


Javascript:

1.graphql.js
   =>core framework written by facebook
   =>Express.js is underlaying framework

2.Apollo
    Apollo is platform for building enterprise graphql application.
    The core of Apollo is "graphql.js and Express.js"
 Graphql application can be built using two arch
 1.monolith arch
 2.Microservices arch.

Java:
1.graphql-java
2.SpringBoot with Graphql
3.DGS Framework - Netflix

Coding style:

1.schema first design
   design schema first and code
2.code first design
   code first , then generate schema out of code

some development framworks support schema first some one support code first,some one first both.

DGS framwork support schema first design.

Getting Started:

create project with dependencies

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'com.netflix.graphql.dgs:graphql-dgs-spring-graphql-starter'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}


Schema design:
...............

resources/schema/schema.graphqls

type Query {
    #nameofApi:Data
    hello:String
}

Implementation:

Data Features:
 Class having schema implemenation.

1.Receive incoming graphql query from client
2.validate that query against our schema
3.retrive the data from the quried schema fields
4.return the data as a response

Writing Data Fetcher

Step 1: Declare class com.wipro/datafetchers

package com.wipro.datafetchers;

public class HelloWorldDataFetcher {
}

Ste 2: Understand about How to map Schema with Java class.

Annotations:
1.@DgsComponent
2.@DgsQuery
3.@DgsMutation
4.@DgsSubscription
5.@DgsData

package com.wipro.datafetchers;

import com.netflix.graphql.dgs.DgsComponent;

@DgsComponent
public class HelloWorldDataFetcher {
}

Step 3:Write Resolver, wirte biz logic for query api

package com.wipro.datafetchers;

import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;

@DgsComponent
public class HelloWorldDataFetcher {

    @DgsQuery
    public String hello(){
        return  "Hello";
    }
}

Test:
http://localhost:8080/graphiql?path=/graphql

query MyQuery {
  hello
}

Response:
{
  "data": {
    "hello": "Hello"
  }
}
.................................................................................
			 What if Schema fieldName and method name is different
...................................................................................
package com.wipro.datafetchers;

import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;

@DgsComponent
public class HelloWorldDataFetcher {

    @DgsQuery(field = "hello")
    public String sayHello(){
        return  "Hello";
    }
}
...................................................................................
			How to handle Not Null
..................................................................................

schema.graphqls
type Query {
    #nameofApi:Data
    hello:String
    hai:String!
}


package com.wipro.datafetchers;

import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;

@DgsComponent
public class HelloWorldDataFetcher {

    @DgsQuery(field = "hello")
    public String sayHello(){
        return  "Hello";
    }
    @DgsQuery(field = "hai")
    public String sayHai(){
        return  null;
    }
}

Testing:
query MyQuery {
  hai
}
Response:
{
  "errors": [
    {
      "message": "The field at path '/hai' was declared as a non null type, but the code involved in retrieving data has wrongly returned a null value.  The graphql specification requires that the parent field be set to null, or if that is non nullable that it bubble up null to its parent and so on. The non-nullable type is 'String' within parent type 'Query'",
      "path": [
        "hai"
      ],
      "extensions": {
        "classification": "NullValueInNonNullableField",
        "errorType": "BAD_REQUEST"
      }
    }
  ],
  "data": null
}
....................................................................................
			 Parameters and args
....................................................................................
package com.wipro.datafetchers;

import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;
import com.netflix.graphql.dgs.InputArgument;

@DgsComponent
public class HelloWorldDataFetcher {

    @DgsQuery(field = "hello")
    public String sayHello() {
        return "Hello";
    }

    @DgsQuery(field = "hai")
    public String sayHai() {
        return null;
    }

    @DgsQuery(field = "name")
    public String getName(@InputArgument String input) {
        return input.toUpperCase();
    }
}

Testing:
query MyQuery {
  name(input:"Subramaian")
}

{
  "data": {
    "name": "SUBRAMAIAN"
  }
}

Variables:

query MyQuery($input:String) {
  name(input:$input)
}

{
  "input":"ram"
}
..................................................................................
			Complex Type,Collections
...................................................................................

GraphQL Comments(For documentation)

"" Single Comment ""

"""
 Multi line
 Multi line
"""

Data sources:
.............

1.REST API As Datasources
2.Database As Datasources


1.REST API as Datasources
.........................
 Travel Booking
    intergalatic

Listing: features offered 

Stage: 1 Basic schema and Data fetcher

type Query{
    "A array of listings to feature on the home of the user application"
    featuredListings:[Listing!]!
}

"A Particular intergalatic location available for booking"
type Listing {
    id:ID!
    "listing tile"
    title:String!
    "The number of bed available"
    numOfBeds:Int
    "The cost per night"
    costPerNight:Float
    "Indicates whether listing is closed for books"
    closedForBookings:Boolean
}

codegen:
 A feature provided by DGS framework, to generated "Model" classes out of schema types.

codegen feature is available directly inside "gradle build" , suppose if your project is based on maven, also available but dgs team is not giving, thrid party plugin.

plugins {
	id 'java'
	id 'org.springframework.boot' version '3.2.5'
	id 'io.spring.dependency-management' version '1.1.4'
	id 'com.netflix.dgs.codegen' version '6.0.3'
}

Just run now the app...

./gradlew bootRun or run main program


After generating, we need to create model class

package com.example.listings.models;

import com.example.listings.generated.types.Listing;

public class ListingModel extends Listing {

}

Data fetcher with mock data:
...........................
package com.example.listings.datafetchers;

import com.example.listings.models.ListingModel;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;

import java.util.List;

@DgsComponent
public class ListingDataFetcher {

    @DgsQuery
    public List<ListingModel> featuredListings(){
        //specific featuredlisting logic goes here
         //array of Listing
        ListingModel listingModel1= new ListingModel();
        listingModel1.setId("1");
        listingModel1.setTitle("Beach House on the edge Ocean");
        listingModel1.setCostPerNight(500.99);
        listingModel1.setNumOfBeds(4);

        ListingModel listingModel2= new ListingModel();
        listingModel2.setId("2");
        listingModel2.setTitle("Beautiful garden, green atmosphere");
        listingModel2.setCostPerNight(500.99);
        listingModel2.setNumOfBeds(4);
        return  List.of(listingModel1,listingModel2);
    }
}

Testing:
query GetFeaturedListing {
  featuredListings {
    id
    title
  }
}
Response:
{
  "data": {
    "featuredListings": [
      {
        "id": "1",
        "title": "Beach House on the edge Ocean"
      },
      {
        "id": "2",
        "title": "Beautiful garden, green atmosphere"
      }
    ]
  }
}
....................................................................................
			 Data Source Integration
....................................................................................

REST AS Data source:
....................

Mock end Point:

https://rt-airlock-services-listing.herokuapp.com/featured-listings

Sample output

[
{
id: "listing-1",
title: "Cave campsite in snowy MoundiiX",
description: "Enjoy this amazing cave campsite in snow MoundiiX, where you'll be one with the nature and wildlife in this wintery planet. All space survival amenities are available. We have complementary dehydrated wine upon your arrival. Check in between 34:00 and 72:00. The nearest village is 3AU away, so please plan accordingly. Recommended for extreme outdoor adventurers.",
costPerNight: 120,
hostId: "user-1",
locationType: "CAMPSITE",
numOfBeds: 2,
photoThumbnail: "https://res.cloudinary.com/apollographql/image/upload/v1644350721/odyssey/federation-course2/illustrations/listings-01.png",
isFeatured: true,
latitude: 1023.4,
longitude: -203.4,
closedForBookings: false,
amenities: [
{
id: "am-2"
},
{
id: "am-10"
},
{
id: "am-11"
},
{
id: "am-12"
},
{
id: "am-13"
},
{
id: "am-26"
},
{
id: "am-27"
},
{
id: "am-16"
},
{
id: "am-15"
},
{
id: "am-14"
},
{
id: "am-17"
},
{
id: "am-18"
},
{
id: "am-31"
},
{
id: "am-20"
},
{
id: "am-24"
}
]
},
]

Task:

1.Fetch featured-listing data from the rest api and map with graphql schema.

2.We need to create service


package com.example.listings.services;

import com.example.listings.models.ListingModel;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestClient;

import java.io.IOException;
import java.util.List;

@Component
public class ListingService {
    private static final String LISTING_API_URL = "https://rt-airlock-services-listing.herokuapp.com";

    private final RestClient client = RestClient.builder().baseUrl(LISTING_API_URL).build();


    private final ObjectMapper mapper = new ObjectMapper();

    //api
    public List<ListingModel> featuredListingsRequest() throws IOException {
        JsonNode response = client.get().uri("/featured-listings").retrieve().body(JsonNode.class);
        if (response != null) {
            return mapper.readValue(response.traverse(), new TypeReference<List<ListingModel>>() {
            });
        }
        return null;
    }

}


Inject service layer into data fetcher.

package com.example.listings.datafetchers;

import com.example.listings.models.ListingModel;
import com.example.listings.services.ListingService;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;
import org.springframework.beans.factory.annotation.Autowired;

import java.io.IOException;
import java.util.List;

@DgsComponent
public class ListingDataFetcher {
    
    private final ListingService listingService;

    @Autowired
    public ListingDataFetcher(ListingService listingService) {
        this.listingService = listingService;
    }

    @DgsQuery
    public List<ListingModel> featuredListings() throws IOException {
          return  listingService.featuredListingsRequest();
    }
}


Restart server:
query GetFeaturedListings {
    featuredListings{
      id
      title
      numOfBeds
    }
}

Response:
{
  "errors": [
    {
      "message": "java.lang.reflect.UndeclaredThrowableException: null",
      "locations": [],
      "path": [
        "featuredListings"
      ],
      "extensions": {
        "errorType": "INTERNAL"
      }
    }
  ],
  "data": null
}

Why this Exception?
  Because rest api provides many fields but our model or schema has only limited fileds

Json mapper not able map all fileds.

Solution:
 Use @JsonIgnoreProperties(ignoreUnknown = true) annotation to skip unmatched properties against model class(Listing) 

package com.example.listings.models;

import com.example.listings.generated.types.Listing;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true)
public class ListingModel extends Listing {

}
.....................................................................................
			 Query Arguments
....................................................................................

https://rt-airlock-services-listing.herokuapp.com/listings/{listing_id}



schema

type Query{
    "A array of listings to feature on the home of the user application"
    featuredListings:[Listing!]!
    "Returns the details about listing"
    listing(id:ID!):Listing
}

Service:
package com.example.listings.services;

import com.example.listings.models.ListingModel;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestClient;

import java.io.IOException;
import java.util.List;

@Component
public class ListingService {
    private static final String LISTING_API_URL = "https://rt-airlock-services-listing.herokuapp.com";

    private final RestClient client = RestClient.builder().baseUrl(LISTING_API_URL).build();


    private final ObjectMapper mapper = new ObjectMapper();

    //api
    public List<ListingModel> featuredListingsRequest() throws IOException {
        JsonNode response = client.get().uri("/featured-listings").retrieve().body(JsonNode.class);
        if (response != null) {
            return mapper.readValue(response.traverse(), new TypeReference<List<ListingModel>>() {
            });
        }
        return null;
    }

    public ListingModel listingRequest(String id) {
        return client.get()
                .uri("/listings/{listing_id}", id)
                .retrieve()
                .body(ListingModel.class);
    }

}

Datafetcher
package com.example.listings.datafetchers;

import com.example.listings.models.ListingModel;
import com.example.listings.services.ListingService;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsQuery;
import com.netflix.graphql.dgs.InputArgument;
import org.springframework.beans.factory.annotation.Autowired;

import java.io.IOException;
import java.util.List;

@DgsComponent
public class ListingDataFetcher {

    private final ListingService listingService;

    @Autowired
    public ListingDataFetcher(ListingService listingService) {
        this.listingService = listingService;
    }

    @DgsQuery
    public List<ListingModel> featuredListings() throws IOException {
          return  listingService.featuredListingsRequest();
    }

    @DgsQuery
    public ListingModel listing(@InputArgument String id){
         return  listingService.listingRequest(id);
    }
}

Testing:



query GetListing($listingId:ID!){
   listing(id:$listingId){
     id
    title
  }
}

Response:

{
  "data": {
    "listing": {
      "id": "listing-1",
      "title": "Cave campsite in snowy MoundiiX"
    }
  }
}
.......................................................................
				What if i am adding new field -requriement
....................................................................................

"A Particular intergalatic location available for booking"
type Listing {
    id:ID!
    "listing tile"
    title:String!
    "Listing Description"
    description:String
    "The number of bed available"
    numOfBeds:Int
    "The cost per night"
    costPerNight:Float
    "Indicates whether listing is closed for books"
    closedForBookings:Boolean
}

Just update the schema. Restart /rebuild app


query GetListing($listingId:ID!){
   listing(id:$listingId){
     id
    title
    description
  }
}

Response:

{
  "data": {
    "listing": {
      "id": "listing-1",
      "title": "Cave campsite in snowy MoundiiX",
      "description": "Enjoy this amazing cave campsite in snow MoundiiX, where you'll be one with the nature and wildlife in this wintery planet. All space survival amenities are available. We have complementary dehydrated wine upon your arrival. Check in between 34:00 and 72:00. The nearest village is 3AU away, so please plan accordingly. Recommended for extreme outdoor adventurers."
    }
  }
}
.....................................................................................
				Nessted Field


schema.graghql
type Query{
    "A array of listings to feature on the home of the user application"
    featuredListings:[Listing!]!
    "Returns the details about listing"
    listing(id:ID!):Listing
}

"A Particular intergalatic location available for booking"
type Listing {
    id:ID!
    "listing tile"
    title:String!
    "Listing Description"
    description:String
    "The number of bed available"
    numOfBeds:Int
    "The cost per night"
    costPerNight:Float
    "Indicates whether listing is closed for books"
    closedForBookings:Boolean
    "Amenities feature"
    amenities: [Amenity!]!
}
type Amenity{
    id:ID!
    "The amenity category the amenity belongs to"
    category:String!
    "The amenity Name"
    name:String!
}

Restart the sever

You can get amenities details

Testing:

query GetListing($listingId:ID!){
   listing(id:$listingId){
     id
    title
    description
    amenities {
      id
      name
      category
    }
  }
}

Response:
{
  "data": {
    "listing": {
      "id": "listing-1",
      "title": "Cave campsite in snowy MoundiiX",
      "description": "Enjoy this amazing cave campsite in snow MoundiiX, where you'll be one with the nature and wildlife in this wintery planet. All space survival amenities are available. We have complementary dehydrated wine upon your arrival. Check in between 34:00 and 72:00. The nearest village is 3AU away, so please plan accordingly. Recommended for extreme outdoor adventurers.",
      "amenities": [
        {
          "id": "am-2",
          "name": "Towel",
          "category": "Accommodation Details"
        },
        {
          "id": "am-10",
          "name": "Oxygen",
          "category": "Space Survival"
        },
        {
          "id": "am-11",
          "name": "Prepackaged meals",
          "category": "Space Survival"
        },
        {
          "id": "am-12",
          "name": "SOS button",
          "category": "Space Survival"
        },
        {
          "id": "am-13",
          "name": "Meteor shower shield",
          "category": "Space Survival"
        },
        {
          "id": "am-26",
          "name": "Meteor showers",
          "category": "Outdoors"
        },
        {
          "id": "am-27",
          "name": "Wildlife",
          "category": "Outdoors"
        },
        {
          "id": "am-16",
          "name": "Panic button",
          "category": "Space Survival"
        },
        {
          "id": "am-15",
          "name": "Water recycler",
          "category": "Space Survival"
        },
        {
          "id": "am-14",
          "name": "First-aid kit",
          "category": "Space Survival"
        },
        {
          "id": "am-17",
          "name": "Emergency life support systems",
          "category": "Space Survival"
        },
        {
          "id": "am-18",
          "name": "Universal translator",
          "category": "Space Survival"
        },
        {
          "id": "am-31",
          "name": "Aquatic breathing aid",
          "category": "Space Survival"
        },
        {
          "id": "am-20",
          "name": "Acid lake access",
          "category": "Outdoors"
        },
        {
          "id": "am-24",
          "name": "Time travel paradoxes",
          "category": "Outdoors"
        }
      ]
    }
  }
}
......................................................................................			  Featured Listings and Amenities
.................................................................................

https://rt-airlock-services-listing.herokuapp.com/featured-listings
{
id: "listing-1",
title: "Cave campsite in snowy MoundiiX",
description: "Enjoy this amazing cave campsite in snow MoundiiX, where you'll be one with the nature and wildlife in this wintery planet. All space survival amenities are available. We have complementary dehydrated wine upon your arrival. Check in between 34:00 and 72:00. The nearest village is 3AU away, so please plan accordingly. Recommended for extreme outdoor adventurers.",
costPerNight: 120,
hostId: "user-1",
locationType: "CAMPSITE",
numOfBeds: 2,
photoThumbnail: "https://res.cloudinary.com/apollographql/image/upload/v1644350721/odyssey/federation-course2/illustrations/listings-01.png",
isFeatured: true,
latitude: 1023.4,
longitude: -203.4,
closedForBookings: false,
amenities: [
{
id: "am-2"
},
{
id: "am-10"
},
{
id: "am-11"
},
{
id: "am-12"
},
{
id: "am-13"
},
{
id: "am-26"
},
{
id: "am-27"
},
{
id: "am-16"
},
{
id: "am-15"
},
{
id: "am-14"
},
{
id: "am-17"
},
{
id: "am-18"
},
{
id: "am-31"
},
{
id: "am-20"
},
{
id: "am-24"
}
]
},

Here you can notedown for this end point we have only amienties id, no other details

just now we have updated our schema  like			

"A Particular intergalatic location available for booking"
type Listing {
    id:ID!
    "listing tile"
    title:String!
    "Listing Description"
    description:String
    "The number of bed available"
    numOfBeds:Int
    "The cost per night"
    costPerNight:Float
    "Indicates whether listing is closed for books"
    closedForBookings:Boolean
    "Amenities feature"
    amenities: [Amenity!]!
}
type Amenity{
    id:ID!
    "The amenity category the amenity belongs to"
    category:String!
    "The amenity Name"
    name:String!
}

Now lets test against featuredlisting for amenities

query GetFeaturedListings {
    featuredListings{
      id
      title
      numOfBeds
      costPerNight
      closedForBookings
      amenities {
        id
        category
      }
    }
}

Response:
{
  "errors": [
    {
      "message": "The field at path '/featuredListings[0]/amenities[0]/category' was declared as a non null type, but the code involved in retrieving data has wrongly returned a null value.  The graphql specification requires that the parent field be set to null, or if that is non nullable that it bubble up null to its parent and so on. The non-nullable type is 'String' within parent type 'Amenity'",
      "path": [
        "featuredListings",
        0,
        "amenities",
        0,
        "category"
      ],
      "extensions": {
        "classification": "NullValueInNonNullableField"
      }
    },
    {
      "message": "The field at path '/featuredListings[0]/amenities[1]/category' was declared as a non null type, but the code involved in retrieving data has wrongly returned a null value.  The graphql specification requires that the parent field be set to null, or if that is non nullable that it bubble up null to its parent and so on. The non-nullable type is 'String' within parent type 'Amenity'",
      "path": [
        "featuredListings",
        0,
        "amenities",
        1,
        "category"
      ],
      "extensions": {
        "classification": "NullValueInNonNullableField"
      }
    },

Here rest api is not mapping amenities details directly. how to get featured listing with amenties data.
              
.....................................................................................
			   Resolver Chain
....................................................................................

query GetListing($listingId:ID!){
   listing(id:$listingId){
    title
  }
}

Here listing is called "Resolver (DataFetcher) (function/method)"

what about title?
   behind the scene "title"   is also relover/datafetcher(method)

method call:
     obj.something()
   
   Query.listing() ---->Listing--->Listing.title()
 
...................................................................................
			DgsDataFetchingEnviroment Object
...................................................................................

Object used to pass data or any information among data fetchers.

Step: 
 Create amenities Resolver and map with Lising

package com.example.listings.datafetchers;

import com.example.listings.models.ListingModel;
import com.example.listings.services.ListingService;
import com.netflix.graphql.dgs.DgsComponent;
import com.netflix.graphql.dgs.DgsData;
import com.netflix.graphql.dgs.DgsQuery;
import com.netflix.graphql.dgs.InputArgument;
import org.springframework.beans.factory.annotation.Autowired;

import java.io.IOException;
import java.util.List;

@DgsComponent
public class ListingDataFetcher {

    private final ListingService listingService;

    @Autowired
    public ListingDataFetcher(ListingService listingService) {
        this.listingService = listingService;
    }

    @DgsQuery
    public List<ListingModel> featuredListings() throws IOException {
          return  listingService.featuredListingsRequest();
    }

    @DgsQuery
    public ListingModel listing(@InputArgument String id){
         return  listingService.listingRequest(id);
    }

    //This is data fecther: fetch amenities data from amenties end

    @DgsData(parentType = "Listing")
    public void amenities(){

    }
}

Return Amenities Result via localContext
.........................................

package com.example.listings.datafetchers;

import com.example.listings.generated.types.Amenity;
import com.example.listings.models.ListingModel;
import com.example.listings.services.ListingService;
import com.netflix.graphql.dgs.*;
import graphql.execution.DataFetcherResult;
import org.springframework.beans.factory.annotation.Autowired;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@DgsComponent
public class ListingDataFetcher {

    private final ListingService listingService;

    @Autowired
    public ListingDataFetcher(ListingService listingService) {
        this.listingService = listingService;
    }

    @DgsQuery
    public List<ListingModel> featuredListings() throws IOException {
        return listingService.featuredListingsRequest();
    }

    @DgsQuery
    public DataFetcherResult<ListingModel> listing(@InputArgument String id) {
        // return  listingService.listingRequest(id);
        ListingModel listing = listingService.listingRequest(id);
        return DataFetcherResult.<ListingModel>newResult()
                .data(listing)
                .localContext(Map.of("hasAmenityData", true))
                .build();
    }

    //This is data fecther: fetch amenities data from amenties end

    @DgsData(parentType = "Listing")
    public List<Amenity> amenities(DgsDataFetchingEnvironment dfe) {
        ListingModel listing = dfe.getSource();
        //getListing id
        String id = listing.getId();
        Map<String,Boolean> localContext = dfe.getLocalContext();
        if(localContext.get("hasAmenityData")){
             return listing.getAmenities();
        }
        //Follow up
    }
}

..........

updating service
package com.example.listings.services;

import com.example.listings.generated.types.Amenity;
import com.example.listings.models.ListingModel;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestClient;

import java.io.IOException;
import java.util.List;

@Component
public class ListingService {
    private static final String LISTING_API_URL = "https://rt-airlock-services-listing.herokuapp.com";

    private final RestClient client = RestClient.builder().baseUrl(LISTING_API_URL).build();


    private final ObjectMapper mapper = new ObjectMapper();

    //api
    public List<ListingModel> featuredListingsRequest() throws IOException {
        JsonNode response = client.get().uri("/featured-listings").retrieve().body(JsonNode.class);
        if (response != null) {
            return mapper.readValue(response.traverse(), new TypeReference<List<ListingModel>>() {
            });
        }
        return null;
    }

    public ListingModel listingRequest(String id) {
        return client.get()
                .uri("/listings/{listing_id}", id)
                .retrieve()
                .body(ListingModel.class);
    }

    public List<Amenity> amenitiesRequest(String listingId) throws IOException {
        //https://rt-airlock-services-listing.herokuapp.com/listings/listing-10/amenities
        JsonNode response = client.get().uri("/listings/{listing_id}/amenities", listingId)
                .retrieve()
                .body(JsonNode.class);
        if (response != null) {
            return mapper.readValue(response.traverse(), new TypeReference<List<Amenity>>() {
            });
        }
        return null;


    }

}


Data fetcher

package com.example.listings.datafetchers;

import com.example.listings.generated.types.Amenity;
import com.example.listings.models.ListingModel;
import com.example.listings.services.ListingService;
import com.netflix.graphql.dgs.*;
import graphql.execution.DataFetcherResult;
import org.springframework.beans.factory.annotation.Autowired;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@DgsComponent
public class ListingDataFetcher {

    private final ListingService listingService;

    @Autowired
    public ListingDataFetcher(ListingService listingService) {
        this.listingService = listingService;
    }

    @DgsQuery
    public List<ListingModel> featuredListings() throws IOException {
        return listingService.featuredListingsRequest();
    }

    @DgsQuery
    public DataFetcherResult<ListingModel> listing(@InputArgument String id) {
        // return  listingService.listingRequest(id);
        ListingModel listing = listingService.listingRequest(id);
        return DataFetcherResult.<ListingModel>newResult()
                .data(listing)
                .localContext(Map.of("hasAmenityData", true))
                .build();
    }

    //This is data fecther: fetch amenities data from amenties end

    @DgsData(parentType = "Listing")
    public List<Amenity> amenities(DgsDataFetchingEnvironment dfe) throws IOException {
        ListingModel listing = dfe.getSource();
        //getListing id
        String id = listing.getId();
        Map<String, Boolean> localContext = dfe.getLocalContext();
        if (localContext.get("hasAmenityData")) {
            return listing.getAmenities();
        }
        //Follow up
        return listingService.amenitiesRequest(id);

    }
}

Testing

https://rt-airlock-services-listing.herokuapp.com/featured-listings

 here only amenity id


https://rt-airlock-services-listing.herokuapp.com/listings/listing-10

 have amenity data

Req:
    

 featuredListings:[Listing!]!

  -Listing data
      |
      amenties
           id
            name X
.....................................................................................
			Data Loaders
.....................................................................................









			